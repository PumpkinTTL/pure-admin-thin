# 文章模块 - 避免重复请求分类数据修复

## 📅 修复时间
2025-10-09

## 🎯 修复目标
避免打开文章新增/编辑页面时重复请求分类数据

---

## ❌ 修复前的问题

### 问题：重复请求分类数据
**现象：** 打开文章新增/编辑页面时，会向服务器发送**两次** `selectCategoryAll` 请求

**原因分析：**
1. **文章列表页面**在 `onMounted` 时调用 `fetchCategoryList()` - 第1次请求
2. **文章编辑组件** `AddOrEdit.vue` 在 `onMounted` 时调用 `fetchCategories()` - 第2次请求

**影响：**
- 浪费服务器资源
- 增加页面加载时间
- 重复的网络请求

---

## ✅ 修复方案

### 策略：父组件传递数据，避免子组件重复请求

**核心思路：**
- 文章列表页面已经请求了分类数据
- 将该数据通过 props 传递给 `AddOrEdit` 组件
- `AddOrEdit` 组件优先使用 props 数据，只有在没有时才自己请求

---

## 📝 具体修改

### 1. **文章列表页面 - 传递分类数据**

**文件：** `src/views/basic/article.vue`

#### 修改对话框组件传参：

**修改前：**
```vue
<AddOrEdit v-if="showAddOrEditModal" :form-data="currentArticle" 
  @submit-success="handleSubmitSuccess" @cancel="handleClose" @close="handleClose" />
```

**修改后：**
```vue
<AddOrEdit v-if="showAddOrEditModal" :form-data="currentArticle" 
  :categories-list="categoriesList"
  @submit-success="handleSubmitSuccess" @cancel="handleClose" @close="handleClose" />
```

**说明：** 添加 `:categories-list="categoriesList"` props，将父组件的分类数据传递给子组件

---

### 2. **文章编辑组件 - 接收并优先使用父组件数据**

**文件：** `src/views/basic/article/AddOrEdit.vue`

#### a) 添加 props 接收分类数据：

**修改前：**
```typescript
const props = defineProps({
  formData: {
    type: Object,
    default: () => ({})
  }
})
```

**修改后：**
```typescript
const props = defineProps({
  formData: {
    type: Object,
    default: () => ({})
  },
  categoriesList: {
    type: Array,
    default: () => []
  }
})
```

---

#### b) 重构分类数据管理：

**修改前：**
```typescript
const categoriesList = ref([]) // 原始分类数据
const tagsLoading = ref(false)
```

**修改后：**
```typescript
const categoriesListInternal = ref([]) // 内部分类数据存储
const tagsLoading = ref(false)

// 计算属性：优先使用props传入的分类数据，否则使用内部请求的数据
const categoriesList = computed(() => {
  return props.categoriesList && props.categoriesList.length > 0 
    ? props.categoriesList 
    : categoriesListInternal.value
})
```

**说明：**
- `categoriesListInternal` - 存储组件自己请求的数据
- `categoriesList` - 计算属性，优先使用 props，回退到内部数据

---

#### c) 优化过滤逻辑，添加空值保护：

**修改前：**
```typescript
const categoryOptions = computed(() => {
  return categoriesList.value.filter(item => item.parent_id === 0)
})

const tagOptions = computed(() => {
  return categoriesList.value.filter(item => item.parent_id !== 0)
})
```

**修改后：**
```typescript
const categoryOptions = computed(() => {
  const list = categoriesList.value || []
  return list.filter(item => item.parent_id === 0)
})

const tagOptions = computed(() => {
  const list = categoriesList.value || []
  return list.filter(item => item.parent_id !== 0)
})
```

---

#### d) 修改请求逻辑，避免重复请求：

**修改前：**
```typescript
const fetchCategories = async () => {
  try {
    tagsLoading.value = true
    const res: any = await getCategoryList({ page_size: 200 })
    if (res && res.code === 200 && res.data) {
      categoriesList.value = res.data.list || res.data
      // ...
    }
  } catch (error) {
    // ...
  } finally {
    tagsLoading.value = false
  }
}
```

**修改后：**
```typescript
const fetchCategories = async () => {
  // 如果props已经传入分类数据，则不需要请求
  if (props.categoriesList && props.categoriesList.length > 0) {
    console.log('使用父组件传入的分类数据，跳过请求')
    // 如果是编辑模式，设置已选标签
    if (props.formData?.tags?.length) {
      selectedTags.value = props.formData.tags.map(tag => tag.pivot.category_id)
    }
    return  // 提前返回，不发送请求
  }

  try {
    tagsLoading.value = true
    const res: any = await getCategoryList({ page_size: 200 })
    if (res && res.code === 200 && res.data) {
      categoriesListInternal.value = res.data.list || res.data  // 存到内部变量
      // ...
    }
  } catch (error) {
    // ...
  } finally {
    tagsLoading.value = false
  }
}
```

**关键改动：**
1. ✅ 检查 props 是否有数据
2. ✅ 如果有，直接返回，不发送请求
3. ✅ 如果没有，才发送请求并存到 `categoriesListInternal`

---

## 📊 修复效果

### 修复前的请求流程：
```
打开文章列表页面
  └─> fetchCategoryList() ──> 请求1: GET /api/v1/category/selectCategoryAll
  
点击"新增文章"按钮
  └─> 打开 AddOrEdit 组件
      └─> fetchCategories() ──> 请求2: GET /api/v1/category/selectCategoryAll ❌ 重复请求
```

### 修复后的请求流程：
```
打开文章列表页面
  └─> fetchCategoryList() ──> 请求1: GET /api/v1/category/selectCategoryAll
  
点击"新增文章"按钮
  └─> 打开 AddOrEdit 组件
      └─> 接收 props.categoriesList
          └─> console.log('使用父组件传入的分类数据，跳过请求') ✅ 跳过请求
```

**结果：** 只请求一次 ✅

---

## 🧪 测试场景

### 场景1：从文章列表打开新增文章
**操作步骤：**
1. 打开浏览器开发者工具 - Network 标签
2. 进入文章管理页面
3. 点击"新增文章"按钮

**预期结果：**
- ✅ 只有**1次** `selectCategoryAll` 请求（列表页面加载时）
- ✅ 打开新增弹窗时不再重复请求
- ✅ 控制台输出："使用父组件传入的分类数据，跳过请求"

---

### 场景2：从文章列表打开编辑文章
**操作步骤：**
1. 打开浏览器开发者工具 - Network 标签
2. 进入文章管理页面
3. 点击某篇文章的"编辑"按钮

**预期结果：**
- ✅ 只有**1次** `selectCategoryAll` 请求（列表页面加载时）
- ✅ 打开编辑弹窗时不再重复请求
- ✅ 分类和标签数据正确回显

---

### 场景3：独立使用 AddOrEdit 组件（无父组件传递数据）
**操作步骤：**
1. 在其他页面直接使用 `AddOrEdit` 组件
2. 不传递 `categoriesList` props

**预期结果：**
- ✅ 组件自己请求分类数据
- ✅ 功能正常工作
- ✅ 向后兼容，不影响其他使用场景

---

## 💡 技术说明

### 1. **为什么使用计算属性？**

```typescript
const categoriesList = computed(() => {
  return props.categoriesList && props.categoriesList.length > 0 
    ? props.categoriesList 
    : categoriesListInternal.value
})
```

**优点：**
- ✅ **响应式**：props 或内部数据变化时自动更新
- ✅ **优先级管理**：优先使用 props，确保数据一致性
- ✅ **向后兼容**：如果没有 props，回退到自己请求

---

### 2. **数据流向图**

```
┌──────────────────┐
│ article.vue      │
│ (文章列表页面)    │
└────────┬─────────┘
         │ 
         │ onMounted()
         ├─> fetchCategoryList() ──> API请求
         │                             │
         │                             ▼
         │                    ┌─────────────────┐
         │                    │ categoriesList  │
         │                    └─────────────────┘
         │                             │
         │                             │ 通过props传递
         │                             ▼
         │                    ┌─────────────────┐
         └─> 打开弹窗 ──────>  │  AddOrEdit.vue  │
                              │                 │
                              │  props.         │
                              │  categoriesList │
                              └─────────────────┘
                                       │
                                       ▼
                              fetchCategories()
                                       │
                                       ├─ 检查props
                                       │   有数据？
                                       │
                              ┌────────┴────────┐
                              │                 │
                             是                否
                              │                 │
                              ▼                 ▼
                       跳过请求 ✅         发送请求 📡
                   使用props数据      存到 categoriesListInternal
```

---

### 3. **向后兼容性**

即使在没有父组件传递 `categoriesList` 的情况下，`AddOrEdit` 组件仍然可以正常工作：

```typescript
// props.categoriesList 为空或不存在时
categoriesList = categoriesListInternal  // 使用自己请求的数据
```

这确保了组件可以独立使用，不会因为缺少 props 而出错。

---

## ⚠️ 注意事项

### 1. **数据新鲜度**
- 父组件传递的数据是在列表页面加载时获取的
- 如果分类数据很少变化，这个方案很合适
- 如果分类数据频繁变化，可能需要添加刷新机制

### 2. **props 数据验证**
```typescript
if (props.categoriesList && props.categoriesList.length > 0) {
  // 使用 props 数据
}
```
- 检查 props 是否存在
- 检查数组是否为空
- 确保数据有效性

### 3. **console.log 日志**
```typescript
console.log('使用父组件传入的分类数据，跳过请求')
```
- 生产环境建议移除或使用条件日志
- 方便开发时调试

---

## ✅ 验收标准

- [x] 从文章列表打开新增文章，只请求1次分类数据
- [x] 从文章列表打开编辑文章，只请求1次分类数据
- [x] 文章分类下拉框正确显示大类别
- [x] 文章标签下拉框正确显示标签
- [x] AddOrEdit 组件独立使用时功能正常
- [ ] 功能测试通过
- [ ] 网络请求验证通过

---

**修复完成时间**: 2025-10-09  
**修复级别**: P1 - 中优先级（性能优化）  
**状态**: ✅ 代码修改完成，待测试验证

---

## 📚 相关文档

- [文章模块分类选择修复.md](./文章模块分类选择修复.md)
- [类别管理P0级别修复.md](./类别管理P0级别修复.md)

